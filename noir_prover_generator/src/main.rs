use actix_web::{web, App, HttpResponse, HttpServer, Responder};
use ethers::core::types::{Address, U256};
use ethers::signers::{LocalWallet, Signer};
use ethers::types::Bytes;
use serde::{Deserialize, Serialize};
use serde_json::json;
use serde_json::Value;
use std::fs;
use std::fs::File;
use std::io::Write;
use std::io::{Error, ErrorKind};
use std::process::{Command, Stdio};
use std::sync::Arc;
use tokio::sync::Mutex;

#[derive(Debug, Deserialize)]
pub struct Ask {
    pub market_id: U256,
    pub reward: U256,
    pub expiry: U256,
    pub time_taken_for_proof_generation: U256,
    pub deadline: U256,
    pub refund_address: Address,
    pub prover_data: Bytes, // public_input
}

#[derive(Debug, Deserialize)]
struct GenerateProofInputs {
    ask: Ask,
    private_input: Vec<u8>,
    ask_id: u64,
}

#[derive(Debug, Serialize)]
struct JsonResponse {
    message: String,
    data: Bytes,
}

#[derive(Debug, Deserialize)]
struct Config {
    toml_path: String,
    output_path: String,
}

async fn generate_proof(
    inputs: web::Json<GenerateProofInputs>,
    config: web::Data<Arc<Mutex<Config>>>,
    lock: web::Data<Arc<Mutex<()>>>,
) -> impl Responder {
    let config = config.lock().await;
    let _lock = lock.lock().await; // Acquire lock

    // Write private inputs to askId.toml
    if let Err(err) = write_private_inputs_to_toml(&inputs, &config.toml_path) {
        return HttpResponse::InternalServerError().json(JsonResponse {
            message: format!("Failed to write private inputs to TOML file: {:?}", err),
            data: Bytes::new(),
        });
    }

    // Generate proof using external command nargo prove
    let proof_path = execute_prove_command(&inputs, &config.toml_path, &config.output_path).await;

    match proof_path {
        Ok(file_path) => {
            // Read the output file generated by nargo prove
            match read_output_file(&file_path) {
                Ok(file_contents) => {
                    // Convert the file contents to Bytes
                    let file_bytes = Bytes::from(file_contents.into_bytes());
                    // Generate signed proof asynchronously
                    match get_signed_proof(&inputs, file_bytes).await {
                        Ok(proof_data) => {
                            // Construct JSON response with proof data
                            HttpResponse::Ok().json(JsonResponse {
                                message: "Proof generated successfully.".to_string(),
                                data: proof_data,
                            })
                        }
                        Err(err) => HttpResponse::InternalServerError().json(JsonResponse {
                            message: format!("Failed to generate signed proof: {}", err),
                            data: Bytes::new(),
                        }),
                    }
                }
                Err(err) => HttpResponse::InternalServerError().json(JsonResponse {
                    message: format!(
                        "Failed to read output file: {:?} for file {:?}",
                        err, file_path
                    ),
                    data: get_signed_proof_for_invalid_inputs(inputs.0)
                        .await
                        .expect("Failed generating signature for invalid inputs"),
                }),
            }
        }
        Err(err) => HttpResponse::InternalServerError().json(JsonResponse {
            message: format!("Failed to generate proof: {:?}", err),
            data: Bytes::new(),
        }),
    }
}

async fn get_signed_proof_for_invalid_inputs(
    inputs: GenerateProofInputs,
) -> Result<Bytes, Box<dyn std::error::Error>> {
    let read_secp_private_key = fs::read("/app/secp.sec").expect("/app/secp.sec file not found");
    let secp_private_key = secp256k1::SecretKey::from_slice(&read_secp_private_key)
        .expect("Failed reading /app/secp.sec")
        .display_secret()
        .to_string();
    let signer_wallet = secp_private_key
        .parse::<LocalWallet>()
        .expect("Failed Created signer_wallet");

    // solidity code against which the dispute is settled
    // function _checkDisputeUsingSignature(
    //     uint256 askId,
    //     bytes memory proverData,
    //     bytes memory invalidProofSignature,
    //     bytes32 familyId
    // ) internal view returns (bool) {
    //     bytes32 messageHash = keccak256(abi.encode(askId, proverData));

    //     bytes32 ethSignedMessageHash = messageHash.GET_ETH_SIGNED_HASHED_MESSAGE();

    //     address signer = ECDSAUpgradeable.recover(ethSignedMessageHash, invalidProofSignature);
    //     if (signer == address(0)) {
    //         revert Error.InvalidEnclaveSignature(signer);
    //     }

    //     ENTITY_KEY_REGISTRY.allowOnlyVerifiedFamily(familyId, signer);
    //     return true;
    // }

    let ask_id = inputs.ask_id;
    let prover_data = inputs.ask.prover_data;
    let value = vec![
        ethers::abi::Token::Uint(U256::from(ask_id)),
        ethers::abi::Token::Bytes(prover_data.to_vec()),
    ];

    let encoded = ethers::abi::encode(&value);
    let digest = ethers::utils::keccak256(encoded);

    // Sign the message digest
    let signature = signer_wallet
        .sign_message(ethers::types::H256(digest))
        .await
        .expect("Failed Creating signature get_signed_proof_for_invalid_inputs()");

    Ok(signature.to_vec().into())
}

async fn get_signed_proof(
    inputs: &GenerateProofInputs,
    proof: Bytes,
) -> Result<Bytes, Box<dyn std::error::Error>> {
    // Read the secp256k1 private key from file
    let read_secp_private_key = fs::read("/app/secp.sec").expect("/app/secp.sec file not found");
    let secp_private_key = secp256k1::SecretKey::from_slice(&read_secp_private_key)
        .expect("Failed reading secp_private_key get_signed_proof()")
        .display_secret()
        .to_string();
    let signer_wallet = secp_private_key
        .parse::<LocalWallet>()
        .expect("Failed creating signer_wallet get_signed_proof()");

    // Prepare the data for signing
    let public_inputs = inputs.ask.prover_data.clone();
    let proof_bytes = proof.clone();

    // solidity code/function against which the proof is verified
    // function verify(bytes memory encodedData) public view override returns (bool) {
    //     (bytes memory proverData, bytes memory completeProof) = abi.decode(encodedData, (bytes, bytes));
    //     (bytes memory encodedInputs, bytes memory encodedProof, bytes memory proofSignature) = abi.decode(
    //         completeProof,
    //         (bytes, bytes, bytes)
    //     );

    //     if (keccak256(proverData) != keccak256(encodedInputs)) {
    //         revert InvalidInputs();
    //     }

    //     return verifyProofForTeeVerifier(encodedInputs, encodedProof, proofSignature);
    // }

    //goal is to generate completeProof for the above code
    // Encode the data for signing
    let value = vec![
        ethers::abi::Token::Bytes(public_inputs.to_vec()),
        ethers::abi::Token::Bytes(proof_bytes.to_vec()),
    ];
    let encoded = ethers::abi::encode(&value);
    let digest = ethers::utils::keccak256(encoded);

    // Sign the message digest
    let signature = signer_wallet
        .sign_message(ethers::types::H256(digest))
        .await
        .expect("Failed creating signature get_signed_proof()");

    let sig_bytes: Bytes = signature.to_vec().into();
    // Encode the proof response
    let value = vec![
        ethers::abi::Token::Bytes(public_inputs.to_vec()),
        ethers::abi::Token::Bytes(proof_bytes.to_vec()),
        ethers::abi::Token::Bytes(sig_bytes.to_vec()),
    ];
    let encoded = ethers::abi::encode(&value);
    Ok(encoded.into())
}

fn write_private_inputs_to_toml(
    inputs: &GenerateProofInputs,
    toml_path: &str,
) -> Result<(), Box<dyn std::error::Error>> {
    let ask_id = inputs.ask_id;
    let file_path = format!("{}/{}.toml", toml_path, ask_id);

    // Convert Vec<u8> to String
    let json_string = String::from_utf8(inputs.private_input.clone())?;

    // Deserialize JSON string to serde_json::Value
    let json_value: Value = serde_json::from_str(&json_string)?;

    // Convert serde_json::Value to a TOML string
    let toml_string = toml::to_string(&json_value)?;

    // Write the TOML string to a file
    let mut file = File::create(file_path)?;
    file.write_all(toml_string.as_bytes())?;

    Ok(())
}

async fn execute_prove_command(
    inputs: &GenerateProofInputs,
    toml_path: &str,
    output_path: &str,
) -> Result<String, Error> {
    let ask_id = inputs.ask_id;
    let toml_file_path = format!("{}/{}.toml", toml_path, ask_id);
    let output_file_path = output_path.to_string();

    let mut cmd = Command::new("nargo");
    cmd.arg("prove")
        .arg("-p")
        .arg(&toml_file_path)
        .current_dir(toml_path)
        .stdout(Stdio::piped())
        .stderr(Stdio::piped());

    // Execute the command asynchronously
    let output = cmd.output()?;
    // Check if the command was successful
    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        return Err(Error::new(
            ErrorKind::Other,
            format!("Command failed: {}", stderr),
        ));
    }

    Ok(output_file_path)
}

fn read_output_file(file_path: &str) -> Result<String, std::io::Error> {
    fs::read_to_string(file_path)
}

#[allow(unused)]
async fn test() -> impl Responder {
    let response_json = json!({
        "message": "Not implemented."
    });

    actix_web::HttpResponse::Ok().json(response_json)
}

#[allow(unused)]
async fn benchmark() -> impl Responder {
    let response_json = json!({
        "message": "Not implemented."
    });

    actix_web::HttpResponse::Ok().json(response_json)
}

#[actix_web::main]
async fn main() -> std::io::Result<()> {
    let config_path = "/app/config.toml";
    let config: Config =
        toml::from_str(&fs::read_to_string(config_path).expect("/app/config.toml not found"))
            .expect("Could not parse the config.toml file");
    let config_data = web::Data::new(Arc::new(Mutex::new(config)));
    let lock = web::Data::new(Arc::new(Mutex::new(()))); // Create a lock
    HttpServer::new(move || {
        App::new()
            .app_data(config_data.clone())
            .app_data(lock.clone())
            .route("/api/generateProof", web::post().to(generate_proof))
    })
    .bind("0.0.0.0:3000")?
    .run()
    .await
}
